@done: 发布note后，将新发布的note显示出来：更新notes，并渲染
@done: 发布note后，将输入框清空
@done: markdown渲染引擎改用 markdown-it，效果更好
@done: 显示发布时间
@done: 将毫秒格式的时间转换成local time
@done: 按发布时间降序排列，新发布(即最后发布)的显示在最上面
@done: 按ctrl enter键发布
@done: 美化notes列表，去掉前缀点号
@done: 美化输入框
@done: 仿照twitter的时间格式化
@done: 新添的note下滑出现
@done: 输入框禁止缩放
@done: 刷新时，输入框的内容仍然保留
@done: 输入框focus时，有渐变边框
@done: 输入框autoresize
@done: 刚加载时，输入框从本地读取数据，如果超出高度，也自动扩宽
@done: 输入框的内容减少时，自动缩小
@done: 时间显示月份有问题
@done: 如果加载完了，将消息传给前端，不要再加载了
@done: 新添加的note后，立即删除最新的note，却删除了最后一个note
原因：在前端，新发布的note被push到notes末尾；而渲染出来的dom却放在最前；删除DOM时，却是按note在notes中的序号来的。
结果当然是将最后一个dom给删掉了。
这只是前端显示除了问题，后端删除的仍然是正确的note，因为发送给后端的数据是对的。
所以刷新后，显示仍然是正确的。
解决办法：
统一前端notes数据和DOM的排序方式。
DOM将最新的排在最前，notes也将最新的排在最前。
从而新发布的note插入notes数组的最前面，即unshift()方法
@done: 当内容为空时，将按钮调暗
@done: 不能发布空内容
@done: 美化删除按钮
@done: 新添加的note背景色由淡蓝色过白色
@done: 在界面左侧垂直显示notepad
@done: 输入即新加载页面时，预览输入的markdown
@done: 当发布note时，将preview清空
@done: 最后一页，在底部显示“没有更多了”
@done: 快删除到底时，加载下一页
办法：每次成功删除后，都检测一下是否到底
但是仍然有问题：删到底之后，返回下一页的数据为空。
造成问题的原因：后端数据被删除后，分页情况已经和前端不一样了。当删到底时，后端数据不够了，isLastPage = true。
即使后端isLastPage = false，也会出现返回数据不对的问题。
前端10个item删除7个，只剩下3个时候，向后端请求的数据序列是 10 ~ 19，而正确的应该是 3~12。
√ 办法1：前端请求页面数据时，发送现存notes的最后一个date，后端从这个date开始往后算10个note，发送给前端。
1。1 将现存notes的最早的date发送出去，即最小的date，即notes的最后一项的date
1。2 后端找到对应的note，往后算10个，发送出去
  办法2：前端删除数据在后端只是做个标记，但不真的删，从而不影响它的序列。
但是这会影响到请求页面数据的逻辑，需要后端先将没有做删除标记的部分筛选出来，做排序，但是这又同样造成上面的问题。
@done: 识别note中的链接，可点击

@todo: 美化markdown渲染效果：quote、代码外边框


@todo: 输入框focus时，placeholder 颜色变浅
@todo: 确认是否要删除
@todo: 将edit, delete放在下拉框中
@todo: 代码超出页面宽度，可以scroll。<code>标签
@todo: 右上角搜索框


===========================================================
@done: 在主页展示notes
@done: 发布 note
@done: 将 markdown 格式的notes渲染成html
@done: 流媒体
@done: 删除note
@done: 重构代码

@todo: 权限系统，需要输入密码登录，或者将输入框不放在主页
只有我能发布新内容，其他只能看到列表。
为了对其他人造成干扰，将登录放在console，输入login(username, keyword)登录
后端在json配置文件中记录username, keyword。
√ 第一步：控制台输入login()，显示输入框、删除按钮
√ 第二步：通过密码登录
√ 第三步：网络中不明文传输密码，而是传送密码的hash
第四步：登录时，后端创建一个随机数，发给前端，前端保存下来，之后的每次请求都要附上这个hash（通过cookie），并对其验证
√ 1。后端login路由，如果密码验证通过，则生成32位随机数；保存到json文件；返回给前端
√ 2。前端获得login路由登录成功的消息后，保存随机数到cookie，设置expire date
√ 3。之后的fetch请求带上cookie（默认行为），后端解析cookie
√ 4。对于需要权限的请求（删除、新建），后端对cookie进行验证：从cookie中读取随机数，从session.json中找是否有匹配的，如果有则返回数据；否则，返回 status: 'failed'
第五步：支持多账户

@todo: 保存cookie由路由操作 res.cookie http://expressjs.com/en/4x/api.html#res.cookie
@todo: 改用 res.json() 发送数据 http://expressjs.com/en/4x/api.html#res.json


@todo: 改用数据库
@todo: 搜索
@todo: 发布图片
@todo: 编辑note
@todo: share