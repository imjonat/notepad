@done: 发布note后，将新发布的note显示出来：更新notes，并渲染
@done: 发布note后，将输入框清空
@done: markdown渲染引擎改用 markdown-it，效果更好
@done: 显示发布时间
@done: 将毫秒格式的时间转换成local time
@done: 按发布时间降序排列，新发布(即最后发布)的显示在最上面
@done: 按ctrl enter键发布
@done: 美化notes列表，去掉前缀点号
@done: 美化输入框
@done: 仿照twitter的时间格式化
@done: 新添的note下滑出现
@done: 输入框禁止缩放
@done: 刷新时，输入框的内容仍然保留
@done: 输入框focus时，有渐变边框
@done: 输入框autoresize
@done: 刚加载时，输入框从本地读取数据，如果超出高度，也自动扩宽
@done: 输入框的内容减少时，自动缩小
@done: 时间显示月份有问题
@done: 如果加载完了，将消息传给前端，不要再加载了
@done: 新添加的note后，立即删除最新的note，却删除了最后一个note
原因：在前端，新发布的note被push到notes末尾；而渲染出来的dom却放在最前；删除DOM时，却是按note在notes中的序号来的。
结果当然是将最后一个dom给删掉了。
这只是前端显示除了问题，后端删除的仍然是正确的note，因为发送给后端的数据是对的。
所以刷新后，显示仍然是正确的。
解决办法：
统一前端notes数据和DOM的排序方式。
DOM将最新的排在最前，notes也将最新的排在最前。
从而新发布的note插入notes数组的最前面，即unshift()方法
@done: 当内容为空时，将按钮调暗
@done: 不能发布空内容
@done: 美化删除按钮
@done: 新添加的note背景色由淡蓝色过白色
@done: 在界面左侧垂直显示notepad
@done: 输入即新加载页面时，预览输入的markdown
@done: 当发布note时，将preview清空
@done: 最后一页，在底部显示“没有更多了”
@done: 快删除到底时，加载下一页
办法：每次成功删除后，都检测一下是否到底
但是仍然有问题：删到底之后，返回下一页的数据为空。
造成问题的原因：后端数据被删除后，分页情况已经和前端不一样了。当删到底时，后端数据不够了，isLastPage = true。
即使后端isLastPage = false，也会出现返回数据不对的问题。
前端10个item删除7个，只剩下3个时候，向后端请求的数据序列是 10 ~ 19，而正确的应该是 3~12。
√ 办法1：前端请求页面数据时，发送现存notes的最后一个date，后端从这个date开始往后算10个note，发送给前端。
1。1 将现存notes的最早的date发送出去，即最小的date，即notes的最后一项的date
1。2 后端找到对应的note，往后算10个，发送出去
  办法2：前端删除数据在后端只是做个标记，但不真的删，从而不影响它的序列。
但是这会影响到请求页面数据的逻辑，需要后端先将没有做删除标记的部分筛选出来，做排序，但是这又同样造成上面的问题。



@todo: 美化markdown渲染效果
@todo: 输入框focus时，placeholder 颜色变浅
@todo: 确认是否要删除
@todo: 识别note中的链接，可点击
@todo: 将edit, delete放在下拉框中
@todo: 代码超出页面宽度，可以scroll。<code>标签
@todo: 右上角搜索框


===========================================================
@done: 在主页展示notes
@done: 发布 note
@done: 将 markdown 格式的notes渲染成html
@done: 流媒体
@done: 删除note

@todo: 改用redis数据库
@todo: 搜索
@todo: 发布图片
@todo: 权限系统，需要输入密码登录，或者将输入框不放在主页
@todo: 编辑note
@todo: 重构代码