    git tag v0.1.0
    2019/03/06 ~ 2019/03/08


![](./assets/mainpage_screenshot.png)


## 实现功能：

- 数据存储在json文件中
- 滑到底加载更多数据
- 点击按钮删除数据

## 界面：
- 输入框高度随内容自动缩放
- 按ctrl-enter键，或者点击按钮，发布新内容
- 支持 markdown 格式，输入时预览效果

## 前端
- [x] 发布note后，将新发布的note显示出来：更新notes，并渲染
- [x] 发布note后，将输入框清空
- [x] markdown渲染引擎改用 markdown-it，效果更好
- [x] 显示发布时间
- [x] 将毫秒格式的时间转换成local time
- [x] 按发布时间降序排列，新发布(即最后发布)的显示在最上面
- [x] 按ctrl enter键发布
- [x] 美化notes列表，去掉前缀点号
- [x] 美化输入框
- [x] 仿照twitter的时间格式化
- [x] 新添的note下滑出现
- [x] 输入框禁止缩放
- [x] 刷新时，输入框的内容仍然保留
- [x] 输入框focus时，有渐变边框
- [x] 输入框autoresize
- [x] 刚加载时，输入框从本地读取数据，如果超出高度，也自动扩宽
- [x] 输入框的内容减少时，自动缩小
- [x] 时间显示月份有问题
- [x] 如果加载完了，将消息传给前端，不要再加载了
- [x] 新添加的note后，立即删除最新的note，却删除了最后一个note
原因：在前端，新发布的note被push到notes末尾；而渲染出来的dom却放在最前；删除DOM时，却是按note在notes中的序号来的。
结果当然是将最后一个dom给删掉了。
这只是前端显示除了问题，后端删除的仍然是正确的note，因为发送给后端的数据是对的。
所以刷新后，显示仍然是正确的。
解决办法：
统一前端notes数据和DOM的排序方式。
DOM将最新的排在最前，notes也将最新的排在最前。
从而新发布的note插入notes数组的最前面，即unshift()方法
- [x] 当内容为空时，将按钮调暗
- [x] 不能发布空内容
- [x] 美化删除按钮
- [x] 新添加的note背景色由淡蓝色过白色
- [x] 在界面左侧垂直显示notepad
- [x] 输入即新加载页面时，预览输入的markdown
- [x] 当发布note时，将preview清空
- [x] 最后一页，在底部显示“没有更多了”
- [x] 快删除到底时，加载下一页
<details>
<summary>办法：每次成功删除后，都检测一下是否到底</summary>

但是仍然有问题：删到底之后，返回下一页的数据为空。

造成问题的原因：后端数据被删除后，分页情况已经和前端不一样了。当删到底时，后端数据不够了，isLastPage = true。

即使后端isLastPage = false，也会出现返回数据不对的问题。

前端10个item删除7个，只剩下3个时候，向后端请求的数据序列是 10 ~ 19，而正确的应该是 3~12。

- [x] 办法1：前端请求页面数据时，发送现存notes的最后一个date，后端从这个date开始往后算10个note，发送给前端。

  - [x] 1.1 将现存notes的最早的date发送出去，即最小的date，即notes的最后一项的date；
  - [x] 1.2 后端找到对应的note，往后算10个，发送出去；

- 办法2：前端删除数据在后端只是做个标记，但不真的删，从而不影响它的序列。

  但是这会影响到请求页面数据的逻辑，需要后端先将没有做删除标记的部分筛选出来，做排序，但是这又同样造成上面的问题。
</details>




## 后端
- [x] 在主页展示notes
- [x] 发布 note
- [x] 将 markdown 格式的notes渲染成html
- [x] 流媒体
- [x] 删除note
- [x] 重构代码